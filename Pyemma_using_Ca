%matplotlib inline
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
import pyemma
from pyemma.util.contexts import settings
import mdtraj as md
import deeptime as dt
import sys
sys.path = [x for x in sys.path if ('amber' not in x) and ('Amber' not in x)]
import pytraj as pt

DIR = '/Users/Desktop/summer/traj'
pdb = '/Users/Desktop/summer/traj/1st.pdb' # protein-only .prmtop or .pdb
# a list of all the MD trajectories, water removed
files = ['/Users/Desktop/summer/traj/a_14sb_1.dcd',
         '/Users/Desktop/summer/traj/a_14sb_2.dcd',
       ]
traj = pt.iterload(files, pdb)
print(traj)

torsions_feat = pyemma.coordinates.featurizer(pdb)
torsions_feat.add_backbone_torsions(cossin=True, periodic=False)
torsions_data = pyemma.coordinates.load(files, features=torsions_feat)
labels = ['backbone\ntorsions']

positions_feat = pyemma.coordinates.featurizer(pdb)
positions_feat.add_selection(positions_feat.select_Ca())
positions_data = pyemma.coordinates.load(files, features=positions_feat)
labels += ['backbone atom\npositions']

def score_cv(data, dim, lag, number_of_splits=10, validation_fraction=0.5):

    # we temporarily suppress very short-lived progress bars
    with pyemma.util.contexts.settings(show_progress_bars=False):
        nval = int(len(data) * validation_fraction)
        scores = np.zeros(number_of_splits)
        for n in range(number_of_splits):
            ival = np.random.choice(len(data), size=nval, replace=False)
            vamp = pyemma.coordinates.vamp(
                [d for i, d in enumerate(data) if i not in ival], lag=lag, dim=dim)
            scores[n] = vamp.score([d for i, d in enumerate(data) if i in ival])
    return scores

dim = 10

fig=plt.figure()
fig, axes = plt.subplots(1, 4, figsize=(12, 3), sharey=True)
for ax, lag in zip(axes.flat, [5, 10, 20, 50]):
    torsions_scores = score_cv(torsions_data, lag=lag, dim=dim)
    scores = [torsions_scores.mean()]
    errors = [torsions_scores.std()]
    positions_scores = score_cv(positions_data, lag=lag, dim=dim)
    scores += [positions_scores.mean()]
    errors += [positions_scores.std()]
    #distances_scores = score_cv(distances_data, lag=lag, dim=dim)
    #scores += [distances_scores.mean()]
    #errors += [distances_scores.std()]
    ax.bar(labels, scores, yerr=errors, color=['C0', 'C1', 'C2'])
    ax.set_title(r'lag time $\tau$={:.1f}ns'.format(lag * 0.1))
    if lag == 5:
        # save for later
        vamp_bars_plot = dict(
            labels=labels, scores=scores, errors=errors, dim=dim, lag=lag)
axes[0].set_ylabel('VAMP2 score')
fig.tight_layout()
fig.savefig(DIR+'/protein_VAMP2_Ca.pdf')

tica = pyemma.coordinates.tica(positions_data, dim=4)
tica_output = tica.get_output()
tica_concatenated = np.concatenate(tica_output)

fig=plt.figure()
fig, axes = plt.subplots(1, 2, figsize=(10, 4))

pyemma.plots.plot_feature_histograms(
    tica_concatenated,
    ax=axes[0],
    feature_labels=['IC1', 'IC2', 'IC3', 'IC4'],
    ylog=True)

pyemma.plots.plot_density(*tica_concatenated[:, :2].T, ax=axes[1], logscale=True)
axes[1].set_xlabel('IC 1')
axes[1].set_ylabel('IC 2')
fig.tight_layout()
fig.savefig(DIR+'/protein_TICAS_Ca.pdf')



fig=plt.figure()
n_clustercenters = [5, 10, 30, 50, 75, 100, 250, 300]

scores = np.zeros((len(n_clustercenters), 5))
for n, k in enumerate(n_clustercenters):
    for m in range(5):
        with pyemma.util.contexts.settings(show_progress_bars=False):
            _cl = pyemma.coordinates.cluster_kmeans(
                tica_output, k=k, max_iter=50, stride=1)
            _msm = pyemma.msm.estimate_markov_model(_cl.dtrajs, 5)
            scores[n, m] = _msm.score_cv(
                _cl.dtrajs, n=1, score_method='VAMP2', score_k=min(10, k))

fig, ax = plt.subplots()
lower, upper = pyemma.util.statistics.confidence_interval(scores.T.tolist(), conf=0.9)
ax.fill_between(n_clustercenters, lower, upper, alpha=0.3)
ax.plot(n_clustercenters, np.mean(scores, axis=1), '-o')
ax.semilogx()
ax.set_xlabel('number of cluster centers')
ax.set_ylabel('VAMP-2 score')
fig.tight_layout()
fig.savefig(DIR+'/protein_number of clusters_Ca.pdf')


cluster = pyemma.coordinates.cluster_kmeans(
    tica_output, k=100, max_iter=50, stride=1)
dtrajs_concatenated = np.concatenate(cluster.dtrajs)

fig=plt.figure()
fig, ax = plt.subplots(figsize=(6, 4))
pyemma.plots.plot_density(
    *tica_concatenated[:, :2].T, ax=ax, cbar=True, alpha=0.3)
ax.scatter(*cluster.clustercenters[:, :2].T, s=5, c='C1')
ax.set_xlabel('IC 1')
ax.set_ylabel('IC 2')
fig.tight_layout()
fig.savefig(DIR+'/protein_ICs_with_clusters_Ca.pdf')


fig=plt.figure()
its = pyemma.msm.its(cluster.dtrajs, lags=5, nits=10, errors="bayes")
pyemma.plots.plot_implied_timescales(its, units='ns', dt=0.1);
fig.savefig(DIR+'/protein_implied_timescales_Ca.pdf')

msm = pyemma.msm.bayesian_markov_model(cluster.dtrajs, lag=100, dt_traj='0.1 ns')
print('fraction of states used = {:.2f}'.format(msm.active_state_fraction))
print('fraction of counts used = {:.2f}'.format(msm.active_count_fraction))

fig=plt.figure()
nstates = 12
cktest = msm.cktest(nstates)
pyemma.plots.plot_cktest(cktest, dt=0.1, units='ns')
fig.savefig(DIR+'/protein_CK test_Ca.pdf')

fig=plt.figure()
fig, axes = plt.subplots(1, 2, figsize=(10, 4), sharex=True, sharey=True)
'''
pyemma.plots.plot_contour(
    *tica_concatenated[:, :2].T,
    msm.pi[dtrajs_concatenated],
    ax=axes[0],
    mask=True,
    cbar_label='stationary distribution')
'''
pyemma.plots.plot_free_energy(
    *tica_concatenated[:, :2].T,
    weights=np.concatenate(msm.trajectory_weights()),
    ax=axes[1],
    legacy=False)
for ax in axes.flat:
    ax.set_xlabel('IC 1')
axes[0].set_ylabel('IC 2')
axes[0].set_title('Stationary distribution', fontweight='bold')
axes[1].set_title('Reweighted free energy surface', fontweight='bold')
fig.tight_layout()
fig.savefig(DIR+'/protein_Distributions_Ca.pdf')

msm.pcca(nstates)


pcca_samples = msm.sample_by_distributions(msm.metastable_distributions, 3)
positions_source = pyemma.coordinates.source(files, features=positions_feat)
pyemma.coordinates.save_trajs(
    positions_source,
    pcca_samples,
    outfiles=['/Users/Desktop/summer/traj/pcca{}_samples.pdb'.format(n + 1)
              for n in range(msm.n_metastable)])


print('state\tÏ€\t\tG/kT')
for i, s in enumerate(msm.metastable_sets):
    p = msm.pi[s].sum()
    print('{}\t{:f}\t{:f}'.format(i + 1, p, -np.log(p)))


from itertools import product

mfpt = np.zeros((nstates, nstates))
for i, j in product(range(nstates), repeat=2):
    mfpt[i, j] = msm.mfpt(
        msm.metastable_sets[i],
        msm.metastable_sets[j])

from pandas import DataFrame
print('MFPT / ns:')
DataFrame(np.round(mfpt, decimals=2), index=range(1, nstates + 1), columns=range(1, nstates + 1))
